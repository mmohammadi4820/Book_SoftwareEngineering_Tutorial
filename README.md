# Book_SoftwareEngineering_Tutorial(ğŸ”¸Release April,2021)

---

## ã€½ï¸Introduction:
Software Engineering provides a standard procedure to design and develop a software.<br>
Software Engineering Tutorial contains all the topics of Software Engineering like Software Engineering Models, Software Development Life Cycle, Requirement Engineering, Software Design tools, Software Design Strategies, Software Design levels, Software Project Management, Software Management activities, Software Management Tools, Software Testing levels, Software Testing approaches, Quality Assurance Vs. Quality control, Manual Testing, Software Maintenance, Software Re-engineering and Software Development Tool such as CASE Tool.<br>





| Front Book Cover  | Back Book Cover  |
|-----------|--------------------|
|<p><img src="https://raw.githubusercontent.com/mmohammadi4820/Book_SoftwareEngineering_Tutorial/main/Cover/Front_SE.jpeg"></p>|<p><img src="https://raw.githubusercontent.com/mmohammadi4820/Book_SoftwareEngineering_Tutorial/main/Cover/Back_SE.jpeg"></p>|
|  <b>Book Name</b>   |   SoftwareEngineering Tutorial  |
| <b>Authors</b>    |   M.Mohammadi, M.H.Mohammadi, S.Y.Moradi|
| <b>language</b>    |  Persian   |
| <b>Printed in the</b>    |  IRAN   |
| <b>Publisher</b>    |   ...  |
| <b>First Printing Edition</b>    |   ...  |
| <b>Print Length</b>    |  ...   |
| <b>ISBN</b>    |  978-600-...-...-.   |

---

<div class="nav">

## Contents
* [Chapter 1](#chapter-1): <i>Software Engineering</i>
* [Chapter 2](#chapter-2): <i>Models</i>
* [Chapter 3](#chapter-3): <i>Software Management</i>
* [Chapter 4](#chapter-4): <i>Software Metrics</i>
* [Chapter 5](#chapter-5): <i>Project Planning</i>
* [Chapter 6](#chapter-6): <i>Risk Management</i>
* [Chapter 7](#chapter-7): <i>Software Requirement</i>
* [Chapter 8](#chapter-8): <i>S/W Configuration</i>
* [Chapter 9](#chapter-9): <i>Software Quality</i>
* [Chapter 10](#chapter-10): <i>Software Design</i>
* [Chapter 11](#chapter-11): <i>Coding</i>
* [Chapter 12](#chapter-12): <i>Software Reliability</i>
* [Chapter 13](#chapter-13): <i>S. Reliability Models</i>
* [Chapter 14](#chapter-14): <i>Software Maintenance</i>

ğŸ”¸ [Authors](#authors)<br>
ğŸ”¸ [Demo](#demo)<br>
ğŸ”¸ [BookCollection](#bookcollection)<br>

</div>

<main>

<article id="chapter-1">

## Chapter 1
- ### Software Engineering
When the first digital computers appeared in the early 1940s, the instructions to make them operate were wired into the machine. Practitioners quickly realized that this design was not flexible and came up with the "stored program architecture" or von Neumann architecture. Thus the division between "hardware" and "software" began with abstraction being used to deal with the complexity of computing.<br>
Programming languages started to appear in the early 1950s and this was also another major step in abstraction. Major languages such as Fortran, ALGOL, PL/I, and COBOL were released in the late 1950 and 1960s to deal with scientific, algorithmic, and business problems respectively. David Parnas introduced the key concept of modularity and information hiding in 1972 to help programmers deal with the ever-increasing complexity of software systems.<br>
The origins of the term "software engineering" have been attributed to various sources. The term "software engineering" appeared in a list of services offered by companies in the June 1965 issue of COMPUTERS and AUTOMATION and was used more formally in the August 1966 issue of Communications of the ACM (Volume 9, number 8) â€œletter to the ACM membershipâ€ by the ACM President Anthony A. Oettinger, it is also associated with the title of a NATO conference in 1968 by Professor Friedrich L. Bauer, the first conference on software engineering. Independently, Margaret Hamilton named the discipline "software engineering" during the Apollo missions to give what they were doing legitimacy. At the time there was perceived to be a "software crisis". The 40th International Conference on Software Engineering (ICSE 2018) celebrates 50 years of "Software Engineering" with the Plenary Sessions' keynotes of Frederick Brooks and Margaret Hamilton.<br>
In 1984, the Software Engineering Institute (SEI) was established as a federally funded research and development center headquartered on the campus of Carnegie Mellon University in Pittsburgh, Pennsylvania, United States. Watts Humphrey founded the SEI Software Process Program, aimed at understanding and managing the software engineering process. The Process Maturity Levels introduced would become the Capability Maturity Model Integration for Development(CMMI-DEV), which has defined how the US Government evaluates the abilities of a software development team.<br>
Modern, generally accepted best-practices for software engineering have been collected by the ISO/IEC JTC 1/SC 7 subcommittee and published as the Software Engineering Body of Knowledge (SWEBOK). Software engineering is considered as one of major computing disciplines.<br>

#### ğŸ”¹ Topics in this chapter include
| <b>Chapter 1</b>  |   |   | 
|-----------|--------------------|-----------|
|1-1 Tutorial |1-3 SDLC |1-5 Requirement Engineering |
|1-2 Software Processes |1-4 SDLC Models | |


</article>

<article id="chapter-2">

## Chapter 2
- ### Models
Winston Royce introduced the Waterfall Model in 1970.This model has five phases: Requirements analysis and specification, design, implementation, and unit testing, integration and system testing, and operation and maintenance. The steps always follow in this order and do not overlap. The developer must complete every phase before the next phase begins. This model is named "Waterfall Model", because its diagrammatic representation resembles a cascade of waterfalls.<br>
etc<br>

#### ğŸ”¹ Topics in this chapter include
| <b>Chapter 2</b>  |   |   | 
|-----------|--------------------|-----------|
|2-1 Waterfall Model |2-4 V-model |2-7 Iterative Model |
|2-2 RAD Model |2-5 Incremental Model |2-8 Big-Bang Model |
|2-3 Spiral Model |2-6 Agile Model |2-9 Prototype Model |


</article>

<article id="chapter-3">

## Chapter 3
- ### Software Management
A project is a group of tasks that need to complete to reach a clear result. A project also defines as a set of inputs and outputs which are required to achieve a goal. Projects can vary from simple to difficult and can be operated by one person or a hundred.<br>
Projects usually described and approved by a project manager or team executive. They go beyond their expectations and objects, and it's up to the team to handle logistics and complete the project on time. For good project development, some teams split the project into specific tasks so they can manage responsibility and utilize team strengths.<br>
etc<br>

#### ğŸ”¹ Topics in this chapter include
| <b>Chapter 3</b>  |   |   | 
|-----------|--------------------|-----------|
|3-1 Project Management |3-2 Activities |3-3 Project Management Tools |


</article>

<article id="chapter-4">

## Chapter 4
- ### Software Metrics
A software metric is a measure of software characteristics which are measurable or countable. Software metrics are valuable for many reasons, including measuring software performance, planning work items, measuring productivity, and many other uses.<br>
Within the software development process, many metrics are that are all connected. Software metrics are similar to the four functions of management: Planning, Organization, Control, or Improvement.<br>
etc<br>

#### ğŸ”¹ Topics in this chapter include
| <b>Chapter 4</b>  |   |   | 
|-----------|--------------------|-----------|
|4-1 Software Metrics |4-4 Functional Point (FP) Analysis |4-7 Information Flow Metrics |
|4-2 Size Oriented Metrics |4-5 Extended Function Point (EFP) Metrics |4-8 Cyclomatic Complexity |
|4-3 Halstead's Software Metrics |4-6 Data Structure Metrics |4-9 Case Tools For Software Metrics |

</article>

<article id="chapter-5">

## Chapter 5
- ### Project Planning
A Software Project is the complete methodology of programming advancement from requirement gathering to testing and support, completed by the execution procedures, in a specified period to achieve intended software product.<br>
etc<br>

#### ğŸ”¹ Topics in this chapter include
| <b>Chapter 5</b>  |   |
|-----------|--------------------|
|5-1 Risk Management |5-3 Project Scheduling |
|5-2 Risk Management Activities |5-4 Personnel Planning |


</article>

<article id="chapter-6">

## Chapter 6
- ### Risk Management
"Tomorrow problems are today's risk." Hence, a clear definition of a "risk" is a problem that could cause some loss or threaten the progress of the project, but which has not happened yet.<br>
These potential issues might harm cost, schedule or technical success of the project and the quality of our software device, or project team morale.<br>
Risk Management is the system of identifying addressing and eliminating these problems before they can damage the project.<br>
We need to differentiate risks, as potential issues, from the current problems of the project.<br>
Different methods are required to address these two kinds of issues.<br>
For example, staff storage, because we have not been able to select people with the right technical skills is a current problem, but the threat of our technical persons being hired away by the competition is a risk.<br>
etc<br>

#### ğŸ”¹ Topics in this chapter include
| <b>Chapter 6</b>  |   |
|-----------|--------------------|
|6-1 Risk Management |6-3 Project Scheduling |
|6-2 Risk Management Activities |6-4 Personnel Planning |


</article>

<article id="chapter-7">
  
## Chapter 7
- ### Software Requirement
The production of the requirements stage of the software development process is Software Requirements Specifications (SRS) (also called a requirements document). This report lays a foundation for software engineering activities and is constructing when entire requirements are elicited and analyzed. SRS is a formal report, which acts as a representation of software that enables the customers to review whether it (SRS) is according to their requirements. Also, it comprises user requirements for a system as well as detailed specifications of the system requirements.<br>
The SRS is a specification for a specific software product, program, or set of applications that perform particular functions in a specific environment. It serves several goals depending on who is writing it. First, the SRS could be written by the client of a system. Second, the SRS could be written by a developer of the system. The two methods create entirely various situations and establish different purposes for the document altogether. The first case, SRS, is used to define the needs and expectation of the users. The second case, SRS, is written for various purposes and serves as a contract document between customer and developer.<br>
etc<br>

#### ğŸ”¹ Topics in this chapter include
| <b>Chapter 7</b>  |   |
|-----------|--------------------|
|7-1 Software Requirement Specifications |7-3 Data Flow Diagrams |7-5 Entity-Relationship Diagram |
|7-2 Requirements Analysis |7-4 Data Dictionaries | |


</article>

<article id="chapter-8">

## Chapter 8
- ### S/W Configuration
When we develop software, the product (software) undergoes many changes in their maintenance phase; we need to handle these changes effectively.<br>
Several individuals (programs) works together to achieve these common goals. This individual produces several work product (SC Items) e.g., Intermediate version of modules or test data used during debugging, parts of the final product.<br>
The elements that comprise all information produced as a part of the software process are collectively called a software configuration.<br>
etc<br>

#### ğŸ”¹ Topics in this chapter include
| <b>Chapter 8</b>  |   |
|-----------|--------------------|
|8-1 Software Configuration Management |8-3 Software Quality Assurance |
|8-2 SCM Process |8-4 Project Monitoring & Control |


</article>

<article id="chapter-9">

## Chapter 9
- ### Software Quality
Software quality product is defined in term of its fitness of purpose. That is, a quality product does precisely what the users want it to do. For software products, the fitness of use is generally explained in terms of satisfaction of the requirements laid down in the SRS document. Although "fitness of purpose" is a satisfactory interpretation of quality for many devices such as a car, a table fan, a grinding machine, etc.for software products, "fitness of purpose" is not a wholly satisfactory definition of quality.<br>
Example: Consider a functionally correct software product. That is, it performs all tasks as specified in the SRS document. But, has an almost unusable user interface. Even though it may be functionally right, we cannot consider it to be a quality product.<br>
etc<br>

#### ğŸ”¹ Topics in this chapter include
| <b>Chapter 9</b>  |   |   | 
|-----------|--------------------|-----------|
|9-1 Software Quality |9-3 SEICMM |9-5 Six Sigma |
|9-2 ISO 9000 Certification |9-4 PCMM | |


</article>

<article id="chapter-10">
  
## Chapter 10
- ### Software Design
Software design is a mechanism to transform user requirements into some suitable form, which helps the programmer in software coding and implementation. It deals with representing the client's requirement, as described in SRS (Software Requirement Specification) document, into a form, i.e., easily implementable using programming language.<br>
The software design phase is the first step in SDLC (Software Design Life Cycle), which moves the concentration from the problem domain to the solution domain. In software design, we consider the system to be a set of components or modules with clearly defined behaviors & boundaries.<br>
etc<br>

#### ğŸ”¹ Topics in this chapter include
| <b>Chapter 10</b>  |   |   | 
|-----------|--------------------|-----------|
|10-1 Software Design |10-3 Coupling and Cohesion |10-5 Object Oriented Design |
|10-2 Software Design Principles |10-4 Function Oriented Design |10-6 User Interface Design |


</article>

<article id="chapter-11">

## Chapter 11
- ### Coding
The coding is the process of transforming the design of a system into a computer language format. This coding phase of software development is concerned with software translating design specification into the source code. It is necessary to write source code & internal documentation so that conformance of the code to its specification can be easily verified.<br>
Coding is done by the coder or programmers who are independent people than the designer. The goal is not to reduce the effort and cost of the coding phase, but to cut to the cost of a later stage. The cost of testing and maintenance can be significantly reduced with efficient coding.<br>
etc<br>

#### ğŸ”¹ Topics in this chapter include
| <b>Chapter 11</b>  |   |   | 
|-----------|--------------------|-----------|
|11-1 Coding |11-2 Programming Style |11-3 Structured Programming |


</article>

<article id="chapter-12">
  
## Chapter 12
- ### Software Reliability
Software Reliability means Operational reliability. It is described as the ability of a system or component to perform its required functions under static conditions for a specific period.<br>
Software reliability is also defined as the probability that a software system fulfills its assigned task in a given environment for a predefined number of input cases, assuming that the hardware and the input are free of error.<br>
Software Reliability is an essential connect of software quality, composed with functionality, usability, performance, serviceability, capability, installability, maintainability, and documentation. Software Reliability is hard to achieve because the complexity of software turn to be high. While any system with a high degree of complexity, containing software, will be hard to reach a certain level of reliability, system developers tend to push complexity into the software layer, with the speedy growth of system size and ease of doing so by upgrading the software.<br>
etc<br>

#### ğŸ”¹ Topics in this chapter include
| <b>Chapter 12</b>  |   |   | 
|-----------|--------------------|-----------|
|12-1 Software Reliability |12-3 Software Reliability Measurement Techniques |12-5 Software Fault Tolerance |
|12-2 Software Failure Mechanisms |12-4 Software Reliability Metrics | |


</article>

<article id="chapter-13">
  
## Chapter 13
- ### S. Reliability Models
A software reliability model indicates the form of a random process that defines the behavior of software failures to time.<br>
Software reliability models have appeared as people try to understand the features of how and why software fails, and attempt to quantify software reliability.<br>
Over 200 models have been established since the early 1970s, but how to quantify software reliability remains mostly unsolved.<br>
There is no individual model that can be used in all situations. No model is complete or even representative.<br>
Most software models contain the following parts:

+ Assumptions
+ Factors

A mathematical function that includes the reliability with the elements. The mathematical function is generally higher-order exponential or logarithmic.<br>
etc<br>

#### ğŸ”¹ Topics in this chapter include
| <b>Chapter 13</b>  |   |   | 
|-----------|--------------------|-----------|
|13-1 Software Reliability Models |13-3 Basic Execution Time Model |13-5 Musa-Okumoto Logarithmic Model |
|13-2 Jelinski & Moranda Model |13-4 Goel-Okumoto (GO) Model | |



</article>

<article id="chapter-14">

## Chapter 14
Software maintenance is a part of the Software Development Life Cycle. Its primary goal is to modify and update software application after delivery to correct errors and to improve performance. Software is a model of the real world. When the real world changes, the software require alteration wherever possible.<br>
Software Maintenance is an inclusive activity that includes error corrections, enhancement of capabilities, deletion of obsolete capabilities, and optimization.<br>
etc<br>

#### ğŸ”¹ Topics in this chapter include
| <b>Chapter 14</b>  |   |   | 
|-----------|--------------------|-----------|
|14-1 Software Maintenance |14-2 Causes of Software Maintenance Problems |14-3 Software Maintenance Cost Factors |


</article>


---
<article id="authors">

## Authors

### The First: "Mahsa Mohammadi"

<p align="center">
  <img width="320" height="320" src="https://raw.githubusercontent.com/mmohammadi4820/Book_SoftwareEngineering_Tutorial/main/Authors/MahsaMohammadi.jpeg">
</p>

Coming soon...

#### My main research interests
- Artificial Intelligence, Machine Learning
- Database Design and Analysis
- Data mining

ğŸŒ ğğğ«ğ¬ğ¨ğ§ğšğ¥ ğğšğ ğ "ğŒğšğ¡ğ¬ğš ğŒğ¨ğ¡ğšğ¦ğ¦ğšğğ¢" ğŸ‘‰ [mmohammadi4820.github.io](https://mmohammadi4820.github.io/)<br>
ğŸ“§ ğ„ğ¦ğšğ¢ğ¥: mmohammadi4820@gmail.com

============================================================================

### The Second: "Mohammad Hossein Mohammadi"

<p align="center">
  <img width="360" height="276" src="https://raw.githubusercontent.com/mmohammadi4820/Book_SoftwareEngineering_Tutorial/main/Authors/MohammadHosseinMohammadi.jpeg">
</p>

Iam currently a Final-year BS.c student at the Department of Computer Engineering, Islamic Azad University, Najafabad Branch (IAUN) (Rank in CWUR) where I am a member of the Bioinformatics Laboratory (BL), advised by Prof. Mehdi Jabalameli. my research involves machine vision, deep learning, and neural networks. where I will complete my thesis on Semantic segmentation of breast cancer pathology images using the U-Net model.

Prior to BL, I finished my Diploma - Mathematics and Physics in Sheikh Ansari Highschool, in September 2015. I tried to use my Diploma to build a solid bedrock for my future research. So in addition to taking many optional bachelor-level courses on math and computer science. I spent 6 months as an intern Programmer at the "CoTech" in Isfahan.

#### My main research interests
- Artificial Intelligence, Machine Learning
- Optimization Algorithm, Neural & NeuroFuzzy Network
- Computer Vision, Signal and Image Processing

ğŸŒ ğğğ«ğ¬ğ¨ğ§ğšğ¥ ğğšğ ğ "ğŒğ¨ğ¡ğšğ¦ğ¦ğšğ ğ‡ğ¨ğ¬ğ¬ğğ¢ğ§ ğŒğ¨ğ¡ğšğ¦ğ¦ğšğğ¢" ğŸ‘‰ [mohammadimh76.github.io](https://mohammadimh76.github.io/)<br>
ğŸ“§ ğ„ğ¦ğšğ¢ğ¥: m.h.mohammadimir2017@gmail.com

============================================================================

### Third: "Seyed Yahya Moradi"

<p align="center">
  <img width="320" height="318" src="https://raw.githubusercontent.com/mmohammadi4820/Book_SoftwareEngineering_Tutorial/main/Authors/SeyedYahyaMoradi.jpeg">
</p>

I am Biomedical Engineer from University of Isfahan. My research interests is Non-Invasive Brain Stimulation, Neuroscience, Brain Mapping & Connectivity, Biomedical AI & IOT, Biosignal Processing.

- Brain stimulation techniques such as tDCS, tACS, tRNS, TMS, Theta-Burst Stimulation (TBS) and Magnetic Seizure Therapy (MST)<br>
- Sleep, Plasticity, Perception, Vision, Navigation<br>
- Q/EEG Decoding; Source Localization; Beamforming; Blind source separation<br>
- Causal Inference; Big Data; Unsupervised & Online learning; Expert System<br>
- Chaos and Fractal Theory<br>

ğŸŒ ğğğ«ğ¬ğ¨ğ§ğšğ¥ ğğšğ ğ "ğ’ğğ²ğğ ğ˜ğšğ¡ğ²ğš ğŒğ¨ğ«ğšğğ¢" ğŸ‘‰ [symoradi.website2.me](http://symoradi.website2.me/)<br>
ğŸ“§ ğ„ğ¦ğšğ¢ğ¥: s.yahyamoradi@yahoo.com 

</article>

---
---

<article id="demo">
  
## Demo 

ğŸ‘‡Click on the link below to see the E-Book Demo!ğŸ‘‡ğŸ˜‰

## (E-Book Demo): ğŸ”º(Coming Soon)ğŸ”º


</article>

---

## BookCollection

<article id="bookcollection">
  
  |TensorFlow Tutorial |ArtificialIntelligence  |[ComprehensiveDatabases<br>Training](https://github.com/mmohammadi4820/Book_ComprehensiveDatabasesTraining)  |[SoftwareTesting Tutorial](https://github.com/mmohammadi4820/Book_SoftwareTesting_Tutorial) |
|-----------|--------------------|-----------|--------------------|
|[<p><img src="https://raw.githubusercontent.com/mmohammadi4820/Book_SoftwareEngineering_Tutorial/main/Cover/Book_TensorFlow.jpeg"></p>](https://google.com)|[<p><img src="https://raw.githubusercontent.com/mmohammadi4820/Book_SoftwareEngineering_Tutorial/main/Cover/Book_ArtificialIntelligence.jpeg"></p>](https://google.com)|[<p><img src="https://raw.githubusercontent.com/mmohammadi4820/Book_SoftwareEngineering_Tutorial/main/Cover/Book_DataBase.jpeg"></p>](https://github.com/mmohammadi4820/Book_ComprehensiveDatabasesTraining)|[<p><img src="https://raw.githubusercontent.com/mmohammadi4820/Book_SoftwareEngineering_Tutorial/main/Cover/Book_SoftwareTesting.jpeg"></p>](https://github.com/mmohammadi4820/Book_SoftwareTesting_Tutorial)|


  
</article>


</main>



